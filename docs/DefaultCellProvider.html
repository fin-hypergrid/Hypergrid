<!DOCTYPE html>

<html>
<head>
  <title>DefaultCellProvider.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="DefaultCellProvider.html">
                DefaultCellProvider.js
              </a>
            
              
              <a class="source" href="DefaultSelectionModel.html">
                DefaultSelectionModel.js
              </a>
            
              
              <a class="source" href="Excel.html">
                Excel.js
              </a>
            
              
              <a class="source" href="Hypergrid.html">
                Hypergrid.js
              </a>
            
              
              <a class="source" href="HypergridRenderer.html">
                HypergridRenderer.js
              </a>
            
              
              <a class="source" href="DefaultGridBehavior.html">
                DefaultGridBehavior.js
              </a>
            
              
              <a class="source" href="InMemoryGridBehavior.html">
                InMemoryGridBehavior.js
              </a>
            
              
              <a class="source" href="QGridBehavior.html">
                QGridBehavior.js
              </a>
            
              
              <a class="source" href="constants.html">
                constants.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>DefaultCellProvider.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">'use strict'</span>;

<span class="hljs-keyword">var</span> constants = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./constants'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>DefaultCellProvider is the cache for cell renderers.  A CellRenderer is an object with a single function ‘paint’.
There should only be a single reused CellRenderer object created for each type of CellRenderer.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Custom CellRenderers can be attached to myCellProvider.cellCache and then referenced through the getCell function that is overridden in your implementation.  Make sure to attach the config argument to the cell renderer that is returne</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>override <a href="DefaultGridBehavior.html">createCellProvider</a> creating an instance of thisobject.  Override members of this object per your specific needs.
see <a href="QGridBehavior.html">QGridBehavior.createCellProvider</a> for an example of overriding createCellProvider.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DefaultCellProvider</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">Object</span>.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.cellCache = {};
    <span class="hljs-keyword">this</span>.initializeCells();
}

<span class="hljs-keyword">var</span> proto = DefaultCellProvider.prototype = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);

proto.constructor = DefaultCellProvider;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>replace this function in on your instance of cellProvider</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.getCell = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(config)</span> </span>{
    <span class="hljs-keyword">var</span> cell = <span class="hljs-keyword">this</span>.cellCache.simpleCellRenderer;
    cell.config = config;
    <span class="hljs-keyword">return</span> cell;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>return the cellRenderer instance for renderering fixed col cells</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.getFixedColCell = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(config)</span> </span>{
    <span class="hljs-keyword">var</span> cell = <span class="hljs-keyword">this</span>.cellCache.simpleCellRenderer;
    cell.config = config;
    <span class="hljs-keyword">return</span> cell;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>return the cellRenderer instance for renderering fixed row cells</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.getFixedRowCell = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(config)</span> </span>{
    <span class="hljs-keyword">var</span> cell = <span class="hljs-keyword">this</span>.cellCache.simpleCellRenderer;
    cell.config = config;
    <span class="hljs-keyword">return</span> cell;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>This is the default cell rendering function for rendering a vanilla cell. Great care was taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from OFGridRenderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> defaultCellPaint = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(gc, x, y, width, height)</span> </span>{

    <span class="hljs-keyword">var</span> colHEdgeOffset = constants.cellPadding,
        halignOffset = <span class="hljs-number">0</span>,
        valignOffset = <span class="hljs-number">0</span>,
        halign = <span class="hljs-keyword">this</span>.config.halign,
        size,
        textWidth;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>setting gc properties are expensive, lets not do it unnecessarily</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (gc.font !== <span class="hljs-keyword">this</span>.config.font) {
        gc.font = <span class="hljs-keyword">this</span>.config.font;
    }
    <span class="hljs-keyword">if</span> (gc.textAlign !== <span class="hljs-string">'left'</span>) {
        gc.textAlign = <span class="hljs-string">'left'</span>;
    }
    <span class="hljs-keyword">if</span> (gc.textBasline !== <span class="hljs-string">'middle'</span>) {
        gc.textBaseline = <span class="hljs-string">'middle'</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>don’t measure the text if we don’t have to as it is very expensive</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (halign === <span class="hljs-string">'right'</span>) {
        size = gc.measureText(<span class="hljs-keyword">this</span>.config.value);
        textWidth = size.width;
        halignOffset = width - colHEdgeOffset - textWidth;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (halign === <span class="hljs-string">'center'</span>) {
        size = gc.measureText(<span class="hljs-keyword">this</span>.config.value);
        textWidth = size.width;
        halignOffset = (width - textWidth) / <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (halign === <span class="hljs-string">'left'</span>) {
        halignOffset = colHEdgeOffset;
    }

    halignOffset = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, halignOffset);
    valignOffset = height / <span class="hljs-number">2</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>fill background only if our bgColor is populated or we are a selected cell</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.config.bgColor || <span class="hljs-keyword">this</span>.config.isSelected) {
        gc.fillStyle = <span class="hljs-keyword">this</span>.config.isSelected ? <span class="hljs-keyword">this</span>.config.bgSelColor : <span class="hljs-keyword">this</span>.config.bgColor;
        gc.fillRect(x, y, width, height);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>draw text</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    gc.fillStyle = <span class="hljs-keyword">this</span>.config.fgColor;
    gc.fillText(<span class="hljs-keyword">this</span>.config.value, x + halignOffset, y + valignOffset);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>emersons utility function for rendering a rounded corner rectangle
<br>TODO:this should be moved to a graphics rendering lib</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> roundRect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, x, y, width, height, radius, fill, stroke)</span> </span>{
    <span class="hljs-keyword">if</span> (!stroke) {
        stroke = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">if</span> (!radius) {
        radius = <span class="hljs-number">5</span>;
    }
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    <span class="hljs-keyword">if</span> (stroke) {
        ctx.stroke();
    }
    <span class="hljs-keyword">if</span> (fill) {
        ctx.fill();
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>emersons paint function for a slider button. currently the user cannot interact with it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> paintSlider = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, x, y, width, height)</span> </span>{
    ctx.strokeStyle = <span class="hljs-string">'white'</span>;
    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.config.value;
    <span class="hljs-keyword">var</span> radius = height / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">var</span> offset = width * val;
    <span class="hljs-keyword">var</span> bgColor = <span class="hljs-keyword">this</span>.config.isSelected ? <span class="hljs-keyword">this</span>.config.bgSelColor : <span class="hljs-string">'#333333'</span>;
    <span class="hljs-keyword">var</span> btnGradient = ctx.createLinearGradient(x, y, x, y + height);
    btnGradient.addColorStop(<span class="hljs-number">0</span>, bgColor);
    btnGradient.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">'#666666'</span>);
    <span class="hljs-keyword">var</span> arcGradient = ctx.createLinearGradient(x, y, x, y + height);
    arcGradient.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">'#aaaaaa'</span>);
    arcGradient.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">'#777777'</span>);
    ctx.fillStyle = btnGradient;
    roundRect(ctx, x, y, width, height, radius, btnGradient);
    <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">1.0</span>) {
        ctx.fillStyle = arcGradient;
    } <span class="hljs-keyword">else</span> {
        ctx.fillStyle = <span class="hljs-string">'#eeeeee'</span>;
    }
    ctx.beginPath();
    ctx.arc(x + <span class="hljs-built_in">Math</span>.max(offset - radius, radius), y + radius, radius, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);
    ctx.fill();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>simple implementation of a sparkline.  see <a href="http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR">Edward Tufte sparkline</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> paintSparkbar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, x, y, width, height)</span> </span>{
    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.config.value;
    <span class="hljs-keyword">if</span> (!val || !val.length) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">var</span> count = val.length;
    <span class="hljs-keyword">var</span> eWidth = width / count;
    <span class="hljs-keyword">var</span> bgColor = <span class="hljs-keyword">this</span>.config.isSelected ? <span class="hljs-keyword">this</span>.config.bgSelColor : <span class="hljs-string">'white'</span>;
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = <span class="hljs-string">'#010167'</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; val.length; i++) {
        <span class="hljs-keyword">var</span> barheight = val[i] / <span class="hljs-number">110</span> * height;
        ctx.fillRect(x + <span class="hljs-number">5</span>, y + height - barheight, eWidth * <span class="hljs-number">0.6666</span>, barheight);
        x = x + eWidth;
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>simple implementation of a sparkline, because it’s a barchart we’ve changed the name ;).  see <a href="http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR">Edward Tufte sparkline</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> paintSparkline = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ctx, x, y, width, height)</span> </span>{
    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.config.value;
    <span class="hljs-keyword">if</span> (!val || !val.length) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">var</span> count = val.length;
    <span class="hljs-keyword">var</span> eWidth = width / count;
    <span class="hljs-keyword">var</span> bgColor = <span class="hljs-keyword">this</span>.config.isSelected ? <span class="hljs-keyword">this</span>.config.bgSelColor : <span class="hljs-string">'white'</span>;
    ctx.fillStyle = bgColor;
    ctx.fillRect(x, y, width, height);
    ctx.strokeStyle = <span class="hljs-string">'#010167'</span>;
    ctx.fillStyle = <span class="hljs-string">'#010167'</span>;
    ctx.beginPath();
    <span class="hljs-keyword">var</span> prev;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; val.length; i++) {
        <span class="hljs-keyword">var</span> barheight = val[i] / <span class="hljs-number">110</span> * height;
        <span class="hljs-keyword">if</span> (!prev) {
            prev = barheight;
        }
        ctx.lineTo(x + <span class="hljs-number">5</span>, y + height - barheight);
        ctx.arc(x + <span class="hljs-number">5</span>, y + height - barheight, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI, <span class="hljs-literal">false</span>);
        x = x + eWidth;
    }
    ctx.stroke();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>default cellRenderers are initialized here.  you can augment the visible on your cellProvider instance: field <code>myCellProviderInstance.cellCache.myCellRendererName = myCellRenderer</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.initializeCells = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.cellCache.simpleCellRenderer = {
        paint: defaultCellPaint
    };
    <span class="hljs-keyword">this</span>.cellCache.sliderCellRenderer = {
        paint: paintSlider
    };
    <span class="hljs-keyword">this</span>.cellCache.sparkbarCellRenderer = {
        paint: paintSparkbar
    };
    <span class="hljs-keyword">this</span>.cellCache.sparklineCellRenderer = {
        paint: paintSparkline
    };
};

<span class="hljs-built_in">module</span>.exports = DefaultCellProvider;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>) { <span class="hljs-comment">//jshint ignore:line</span>
    <span class="hljs-built_in">window</span>.DefaultCellProvider = DefaultCellProvider; <span class="hljs-comment">//jshint ignore:line</span>
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
